"""
Flaskã¨LINE Bot SDKã‚’ä½¿ç”¨ã—ãŸLINE Botã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€‚

ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ã¦ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ã™ã‚‹
ã‚·ãƒ³ãƒ—ãƒ«ãªLINE Botã‚’æä¾›ã—ã¾ã™ã€‚
"""

import os
import re
import subprocess
import sys
import traceback
from datetime import datetime, timedelta

# ç’°å¢ƒå¤‰æ•°ã®èª­ã¿è¾¼ã¿ï¼ˆãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®å®Ÿè¡Œã‚’å‰æï¼‰
from dotenv import load_dotenv

# .envãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¨­å®šï¼ˆãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ï¼‰
current_dir = os.getcwd()
root_dir = current_dir

# ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã©ã†ã‹ã®åˆ¤å®š
if os.path.basename(current_dir) == "src":
    # srcãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰å®Ÿè¡Œã•ã‚ŒãŸå ´åˆã¯ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•
    root_dir = os.path.join(current_dir, "..", "..", "..")
    root_dir = os.path.abspath(root_dir)
    os.chdir(root_dir)
    print(f"[INFO] Working directory changed to root: {root_dir}")

# .envãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹è¨­å®š
env_file_path = os.path.join("Lesson25", "uma3soft-app", ".env")
if os.path.exists(env_file_path):
    load_dotenv(env_file_path)
    print(f"[INFO] Loaded .env from: {env_file_path}")
else:
    load_dotenv()  # é€šå¸¸ã®ãƒ­ãƒ¼ãƒ‰
    print("[INFO] Loaded .env from default location")

# ãƒ‘ã‚¹ã®è¨­å®šï¼ˆãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®å®Ÿè¡Œã‚’å‰æï¼‰
src_path = os.path.join("Lesson25", "uma3soft-app", "src")
if src_path not in sys.path:
    sys.path.insert(0, src_path)

from chathistory2db import load_chathistory_to_chromadb
from flask import Flask, request
from integrated_conversation_system import IntegratedConversationSystem
from langchain_chroma import Chroma
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_openai import ChatOpenAI
from linebot.v3.messaging import ApiClient, Configuration, MessagingApi
from linebot.v3.messaging.models import ReplyMessageRequest, TextMessage
from linebot.v3.webhook import WebhookHandler
from linebot.v3.webhooks import MessageEvent, TextMessageContent
from reminder_schedule import send_reminder_via_line
from uma3_chroma_improver import Uma3ChromaDBImprover

# Chains import disabled - not available in current LangChain version
# Documents chain import disabled

# OpenAI APIè¨­å®šï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼‰
if "OPENAI_API_KEY" not in os.environ:
    print("âš ï¸ OPENAI_API_KEYã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„")
    sys.exit(1)

# ChromaDBã®ä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå®šæ•°ï¼ˆå®Ÿè¡Œãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ï¼‰
# å®Ÿè¡Œãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒ C:\work\ws_python\GenerationAiCamp ã®å ´åˆã‚’æƒ³å®š
# ChromaDBã®ä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå®šæ•°ï¼ˆC:\work\ws_python\GenerationAiCamp>ã‹ã‚‰å®Ÿè¡Œï¼‰
PERSIST_DIRECTORY = "Lesson25/uma3soft-app/db/chroma_store"
CONVERSATION_DB_PATH = "Lesson25/uma3soft-app/db/conversation_history.db"

# Botã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼‰
BOT_USER_ID = os.getenv("BOT_USER_ID", "U2b1bb2a638b714727085c7317a3b54a0")

# ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®åˆæœŸåŒ–
CHAT_HISTORY = []

app = Flask(__name__)

# LINE Botè¨­å®šï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼‰
ACCESS_TOKEN = os.getenv("LINE_ACCESS_TOKEN")
CHANNEL_SECRET = os.getenv("LINE_CHANNEL_SECRET")
DEBUG_SKIP_SIGNATURE = os.getenv("DEBUG_SKIP_SIGNATURE", "false").lower() == "true"

if not ACCESS_TOKEN or not CHANNEL_SECRET:
    print("âš ï¸ LINE_ACCESS_TOKENã¾ãŸã¯LINE_CHANNEL_SECRETã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„")
    sys.exit(1)

if DEBUG_SKIP_SIGNATURE:
    print(
        "âš ï¸ [DEBUG MODE] ç½²åæ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã„ã¾ã™ã€‚æœ¬ç•ªç’°å¢ƒã§ã¯ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚"
    )

# LINE Bot SDKã®åˆæœŸåŒ–
configuration = Configuration(access_token=ACCESS_TOKEN)
line_api = MessagingApi(ApiClient(configuration))
handler = WebhookHandler(CHANNEL_SECRET)

# åŸ‹ã‚è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã¨ãƒ™ã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–
embedding_model = HuggingFaceEmbeddings(
    model_name="sentence-transformers/all-MiniLM-L6-v2"
)
vector_db = Chroma(
    persist_directory=PERSIST_DIRECTORY, embedding_function=embedding_model
)

# ChromaDBç²¾åº¦å‘ä¸Šæ©Ÿèƒ½ã®åˆæœŸåŒ–
chroma_improver = Uma3ChromaDBImprover(vector_db)

# çµ±åˆä¼šè©±ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
integrated_conversation_system = IntegratedConversationSystem(
    chroma_persist_directory=PERSIST_DIRECTORY,
    conversation_db_path=CONVERSATION_DB_PATH,
    embeddings_model=embedding_model
)

print(f"[INIT] Integrated conversation system initialized")
print(f"[INIT] ChromaDB path: {PERSIST_DIRECTORY}")
print(f"[INIT] ConversationDB path: {CONVERSATION_DB_PATH}")


def format_message_for_mobile(text):
    """
    ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§è¦‹ã‚„ã™ã„å½¢å¼ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ•´å½¢ã™ã‚‹

    Args:
        text (str): æ•´å½¢å‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        str: æ•´å½¢å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    """
    if not text:
        return text

    # åŸºæœ¬çš„ãªæ”¹è¡Œã®æ­£è¦åŒ–
    formatted_text = text.replace("\r\n", "\n").replace("\r", "\n")

    # é•·ã„æ–‡ç« ã‚’æ®µè½ã«åˆ†å‰²
    sentences = []
    current_sentence = ""

    for char in formatted_text:
        current_sentence += char
        if char in ["ã€‚", "ï¼", "ï¼Ÿ", "\n"] and len(current_sentence.strip()) > 0:
            sentences.append(current_sentence.strip())
            current_sentence = ""

    if current_sentence.strip():
        sentences.append(current_sentence.strip())

    # æ®µè½ã‚’æ§‹ç¯‰
    paragraphs = []
    current_paragraph = ""

    for sentence in sentences:
        if sentence.startswith(("1.", "2.", "3.", "4.", "5.", "â€¢", "ãƒ»", "-")):
            if current_paragraph:
                paragraphs.append(current_paragraph.strip())
                current_paragraph = ""
            paragraphs.append(sentence)
        elif len(current_paragraph) + len(sentence) > 100:
            if current_paragraph:
                paragraphs.append(current_paragraph.strip())
            current_paragraph = sentence
        else:
            if current_paragraph:
                current_paragraph += " " + sentence
            else:
                current_paragraph = sentence

    if current_paragraph:
        paragraphs.append(current_paragraph.strip())

    # æ®µè½é–“ã«é©åˆ‡ãªæ”¹è¡Œã‚’è¿½åŠ 
    formatted_paragraphs = []
    for paragraph in paragraphs:
        if paragraph.startswith(("1.", "2.", "3.", "4.", "5.", "â€¢", "ãƒ»", "-")):
            formatted_paragraphs.append(paragraph)
        else:
            formatted_paragraphs.append(paragraph)

    result = "\n\n".join(formatted_paragraphs)

    # çµµæ–‡å­—ã®è¿½åŠ ï¼ˆäºˆå®šé–¢é€£ã®å ´åˆï¼‰
    if any(keyword in result for keyword in ["äºˆå®š", "å¤§ä¼š", "ç·´ç¿’", "è©¦åˆ"]):
        result = "ğŸ“… " + result

    return result


def split_long_message(text, max_length=1000):
    """
    é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¤‡æ•°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«åˆ†å‰²ã™ã‚‹

    Args:
        text (str): åˆ†å‰²å¯¾è±¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        max_length (int): 1ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ€å¤§é•·

    Returns:
        list: åˆ†å‰²ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒªã‚¹ãƒˆ
    """
    if len(text) <= max_length:
        return [text]

    messages = []
    current_message = ""

    paragraphs = text.split("\n\n")

    for paragraph in paragraphs:
        if len(current_message) + len(paragraph) + 2 <= max_length:
            if current_message:
                current_message += "\n\n" + paragraph
            else:
                current_message = paragraph
        else:
            if current_message:
                messages.append(current_message)

            if len(paragraph) > max_length:
                # æ®µè½ãŒé•·ã™ãã‚‹å ´åˆã€æ–‡ã§åˆ†å‰²
                sentences = paragraph.split("ã€‚")
                temp_message = ""
                for sentence in sentences:
                    if sentence and len(temp_message) + len(sentence) + 1 <= max_length:
                        if temp_message:
                            temp_message += "ã€‚" + sentence
                        else:
                            temp_message = sentence
                    else:
                        if temp_message:
                            messages.append(
                                temp_message + "ã€‚"
                                if not temp_message.endswith("ã€‚")
                                else temp_message
                            )
                        temp_message = sentence
                if temp_message:
                    current_message = (
                        temp_message + "ã€‚"
                        if not temp_message.endswith("ã€‚")
                        else temp_message
                    )
                else:
                    current_message = ""
            else:
                current_message = paragraph

    if current_message:
        messages.append(current_message)

    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¤‡æ•°ã«åˆ†å‰²ã•ã‚ŒãŸå ´åˆã€ç•ªå·ã‚’è¿½åŠ 
    if len(messages) > 1:
        numbered_messages = []
        for i, msg in enumerate(messages, 1):
            numbered_messages.append(f"({i}/{len(messages)})\n{msg}")
        return numbered_messages

    return messages


@app.route("/")
def health_check():
    """
    ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‹•ä½œç¢ºèªç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‚

    Returns:
        str: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹
    """
    import datetime

    current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[HEALTH] Health check accessed at {current_time}")
    print(f"[HEALTH] Request from: {request.remote_addr}")
    print(f"[HEALTH] User-Agent: {request.headers.get('User-Agent', 'Unknown')}")

    status_info = {
        "status": "running",
        "timestamp": current_time,
        "webhook_url": "/callback",
        "chromadb_path": PERSIST_DIRECTORY,
    }

    return f"LINE Bot Application is running!\nStatus: {status_info}", 200


@app.route("/callback", methods=["POST"])
def callback():
    """
    LINE MessagingAPIã‹ã‚‰ã®Webhookã‚’å—ä¿¡ã™ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‚

    Returns:
        str: ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ "OK"
    """
    print(f"[WEBHOOK] Callback endpoint accessed! Method: {request.method}")
    print(f"[HEADERS] Request headers: {dict(request.headers)}")

    try:
        body = request.get_data(as_text=True)
        print(f"[BODY] Received body length: {len(body)}")
        print(f"[BODY] Content: {body[:200]}...")  # æœ€åˆã®200æ–‡å­—ã‚’ãƒ­ã‚°å‡ºåŠ›

        # DEBUG_SKIP_SIGNATUREç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç½²åæ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if DEBUG_SKIP_SIGNATURE:
            print("âš ï¸ [DEBUG MODE] ç½²åæ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã„ã¾ã™")
            # ç½²åæ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç›´æ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†
            import json

            webhook_body = json.loads(body)
            events = webhook_body.get("events", [])

            for event in events:
                if (
                    event.get("type") == "message"
                    and event.get("message", {}).get("type") == "text"
                ):
                    user_message = event["message"]["text"]
                    user_id = event["source"]["userId"]
                    print(f"[MESSAGE] User {user_id}: {user_message}")

                    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚’å‘¼ã³å‡ºã—
                    handle_message_event_direct(event)

            print(
                "[SUCCESS] Message handled successfully (signature verification skipped)"
            )
            return "OK", 200

        # é€šå¸¸ã®ç½²åæ¤œè¨¼å‡¦ç†
        signature = request.headers.get("X-Line-Signature", "")
        if not signature:
            print("[ERROR] X-Line-Signature header is missing")
            print("[DEBUG] Available headers:", list(request.headers.keys()))
            return "Bad Request: Missing signature", 400

        # ãƒ‡ãƒãƒƒã‚°: è¨­å®šå€¤ç¢ºèª
        channel_secret = os.getenv("LINE_CHANNEL_SECRET")
        print(
            f"[DEBUG] Channel Secret length: {len(channel_secret) if channel_secret else 0}"
        )
        print(f"[DEBUG] Signature received: {signature}")

        # ç½²åæ¤œè¨¼ã‚’ã‚ˆã‚Šè©³ç´°ã«ãƒ­ã‚°å‡ºåŠ›
        import base64
        import hashlib
        import hmac

        if channel_secret:
            expected_signature = base64.b64encode(
                hmac.new(
                    channel_secret.encode("utf-8"), body.encode("utf-8"), hashlib.sha256
                ).digest()
            ).decode("utf-8")
            print(f"[DEBUG] Expected signature: {expected_signature}")
            print(f"[DEBUG] Signatures match: {signature == expected_signature}")

        # LINE Webhookå‡¦ç†
        handler.handle(body, signature)
        print("[SUCCESS] Message handled successfully")
        return "OK", 200

    except Exception as e:
        print(f"[ERROR] Exception in callback: {type(e).__name__}: {e}")
        traceback.print_exc()
        # LINE ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã¯200ã‚’è¿”ã—ã¦å†é€ã‚’é˜²ã
        return "OK", 200


def handle_message_event_direct(event):
    """
    ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ç›´æ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†é–¢æ•°

    Args:
        event (dict): LINE Webhook event dictionary
    """
    try:
        if (
            event.get("type") == "message"
            and event.get("message", {}).get("type") == "text"
        ):
            user_message = event["message"]["text"]
            user_id = event["source"]["userId"]
            group_id = event["source"].get("groupId") or event["source"].get("roomId")

            print(
                f"ğŸ” [DEBUG] ãƒ¦ãƒ¼ã‚¶ãƒ¼ {user_id[:8]}... ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {user_message}"
            )

            # ã‚°ãƒ«ãƒ¼ãƒ—IDã‚’ã‚»ãƒƒãƒˆï¼ˆæœ‰åŠ¹ãªIDã®å ´åˆã®ã¿ï¼‰
            if group_id and len(group_id) >= 10:
                os.environ["TO_USER_ID"] = group_id
                print(f"ğŸ” [DEBUG] Set target group ID: {group_id[:20]}...")
            elif user_id and len(user_id) >= 10:
                os.environ["TO_USER_ID"] = user_id
                print(f"ğŸ” [DEBUG] Set target user ID: {user_id[:20]}...")
            else:
                print("ğŸ” [DEBUG] No valid target ID found")

            # Botãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ç°¡å˜ãªãƒã‚§ãƒƒã‚¯ï¼‰
            if "@Bot" in user_message or user_message.startswith("Bot"):
                print("ğŸ” [DEBUG] BotãŒãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚Œã¾ã—ãŸï¼ˆæ¤œå‡ºï¼‰")

                # ChromaDBæ¤œç´¢ã‚’å®Ÿè¡Œ
                results = chroma_improver.schedule_aware_search(
                    user_message, k=6, score_threshold=0.5
                )

                print(f"ğŸ” [DEBUG] æ¤œç´¢çµæœ: {len(results)}ä»¶")

                # LLMã§å¿œç­”ç”Ÿæˆï¼ˆå®Ÿéš›ã®é€ä¿¡ã¯ã—ãªã„ï¼‰
                if results:
                    context = "\n".join([doc.page_content for doc in results])
                    print(f"ğŸ” [DEBUG] ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆé•·: {len(context)}æ–‡å­—")
                    print(f"ğŸ“¤ [DEBUG] å¿œç­”ç”Ÿæˆå®Œäº†ï¼ˆå®Ÿéš›ã®é€ä¿¡ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰")
                else:
                    print("ğŸ” [DEBUG] ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            else:
                print("ğŸ” [DEBUG] ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ã€å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—")

    except Exception as e:
        print(
            f"[ERROR] Exception in handle_message_event_direct: {type(e).__name__}: {e}"
        )
        traceback.print_exc()


@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    """
    ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ãŸéš›ã®å‡¦ç†ã€‚

    Args:
        event: LINEã‹ã‚‰é€ä¿¡ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
    """
    print("[MESSAGE] handle_message function called!")  # é–¢æ•°ãŒå‘¼ã°ã‚ŒãŸã“ã¨ã‚’ç¢ºèª

    try:
        # ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æƒ…å ±ã®å–å¾—
        mention = getattr(event.message, "mention", None)
        is_mentioned_by_other = False

        if mention and hasattr(mention, "mentionees"):
            for m in mention.mentionees:
                # Botè‡ªèº«ãŒãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚Œã¦ã„ã‚‹ã‹ã¤ã€é€ä¿¡è€…ãŒBotè‡ªèº«ã§ãªã„
                if m.user_id == BOT_USER_ID and m.is_self:
                    if getattr(event.source, "user_id", None) != BOT_USER_ID:
                        is_mentioned_by_other = True

        user_id = getattr(event.source, "user_id", "private")
        group_id = getattr(event.source, "group_id", None) or getattr(event.source, "room_id", None)
        text = event.message.text

        # ã‚°ãƒ«ãƒ¼ãƒ—IDã‚’ã‚»ãƒƒãƒˆï¼ˆæœ‰åŠ¹ãªIDã®å ´åˆã®ã¿ï¼‰
        if group_id and group_id != "unknown" and len(group_id) >= 10:
            os.environ["TO_USER_ID"] = group_id
            print(f"[GROUP] Set target group ID: {group_id[:20]}...")
        else:
            # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆã®å ´åˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ä½¿ç”¨
            if user_id and user_id != "private" and len(user_id) >= 10:
                os.environ["TO_USER_ID"] = user_id
                print(f"[USER] Set target user ID: {user_id[:20]}...")
            else:
                print("[WARNING] No valid target ID found in message event")

        # BotãŒãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚ŒãŸã‹åˆ¤å®š
        if is_mentioned_by_other or "@Bot" in text:
            print("[MENTION] BotãŒãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚Œã¾ã—ãŸï¼")

            # çµ±åˆä¼šè©±ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ã—ã¦å¿œç­”ã‚’ç”Ÿæˆ
            print(f"[INTEGRATED] Using integrated conversation system for user: {user_id}")

            # LLMã®åˆæœŸåŒ–
            llm = ChatOpenAI(
                model="gpt-3.5-turbo",
                temperature=0.3,
                openai_api_key=os.getenv("OPENAI_API_KEY"),
            )

            try:
                # çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã§å¿œç­”ç”Ÿæˆ
                response_result = integrated_conversation_system.generate_integrated_response(
                    user_id, text, llm
                )

                if "error" in response_result:
                    # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
                    print(f"[ERROR] Integrated system error: {response_result.get('error_message', 'Unknown error')}")

                    # å¾“æ¥ã®ChromaDBæ¤œç´¢ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    results = chroma_improver.schedule_aware_search(
                        text, k=6, score_threshold=0.5
                    )

                    if results:
                        context = "\n".join([doc.page_content for doc in results])

                        prompt_template = ChatPromptTemplate.from_messages([
                            (
                                "system",
                                """ã‚ãªãŸã¯å„ªç§€ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ä»¥ä¸‹ã®é–¢é€£æƒ…å ±ã‚’å‚è€ƒã«ã—ã¦ã€
                                ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«è‡ªç„¶ã§è¦ªã—ã¿ã‚„ã™ãç­”ãˆã¦ãã ã•ã„ã€‚
                                å›ç­”æ™‚ã¯ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§èª­ã¿ã‚„ã™ã„ã‚ˆã†ã«ã€é©åº¦ã«æ”¹è¡Œã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚

                                ---
                                {context}
                                ---""",
                            ),
                            ("human", "{input}"),
                        ])

                        formatted_prompt = prompt_template.format_messages(
                            context=context, input=text
                        )
                        response = llm.invoke(formatted_prompt)
                        ai_msg = {"answer": response.content}
                    else:
                        ai_msg = {"answer": "ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚é–¢é€£ã™ã‚‹æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"}
                else:
                    # æ­£å¸¸å¿œç­”ã®å ´åˆ
                    ai_msg = {"answer": response_result["response"]}

                    # å¿œç­”æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
                    context_info = response_result.get("context_used", {})
                    print(f"[INTEGRATED] Response generated successfully")
                    print(f"[INTEGRATED] ChromaDB results: {context_info.get('chroma_results', 0)}")
                    print(f"[INTEGRATED] Conversation history: {context_info.get('conversation_history', 0)}")
                    print(f"[INTEGRATED] Response type: {response_result.get('response_type', 'unknown')}")

                    # ãƒ¦ãƒ¼ã‚¶ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
                    user_profile = context_info.get('user_profile', {})
                    if user_profile:
                        print(f"[PROFILE] User conversation count: {user_profile.get('conversation_count', 0)}")
                        if user_profile.get('interests'):
                            print(f"[PROFILE] User interests: {user_profile['interests'][:3]}")

                    # â˜…â˜…â˜… é‡è¦ï¼šçµ±åˆã‚·ã‚¹ãƒ†ãƒ ã§ç”Ÿæˆã—ãŸä¼šè©±ã‚’å±¥æ­´ã«ä¿å­˜ â˜…â˜…â˜…
                    try:
                        integrated_conversation_system.history_manager.save_conversation(
                            user_id, text, ai_msg["answer"],
                            metadata={"source": "line_mention", "response_type": response_result.get('response_type', 'integrated')}
                        )
                        print(f"[HISTORY] âœ… Saved conversation to history (user: {user_id[:10]}...)")
                    except Exception as save_error:
                        print(f"[WARNING] âŒ Failed to save conversation to history: {save_error}")
                        traceback.print_exc()

            except Exception as e:
                print(f"[ERROR] Integrated conversation system error: {e}")
                traceback.print_exc()

                # ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå¾“æ¥ã®å‡¦ç†
                results = chroma_improver.schedule_aware_search(
                    text, k=6, score_threshold=0.5
                )

                if results:
                    context = "\n".join([doc.page_content for doc in results])

                    prompt_template = ChatPromptTemplate.from_messages([
                        (
                            "system",
                            """ã‚ãªãŸã¯å„ªç§€ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ä»¥ä¸‹ã®é–¢é€£æƒ…å ±ã‚’å‚è€ƒã«ã—ã¦ã€
                            ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«è‡ªç„¶ã§è¦ªã—ã¿ã‚„ã™ãç­”ãˆã¦ãã ã•ã„ã€‚

                            ---
                            {context}
                            ---""",
                        ),
                        ("human", "{input}"),
                    ])

                    formatted_prompt = prompt_template.format_messages(
                        context=context, input=text
                    )
                    response = llm.invoke(formatted_prompt)
                    ai_msg = {"answer": response.content}
                else:
                    ai_msg = {"answer": "ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ç¾åœ¨å¿œç­”ã®ç”Ÿæˆã«å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚"}

                # â˜…â˜…â˜… ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ä¼šè©±å±¥æ­´ã«ä¿å­˜ â˜…â˜…â˜…
                try:
                    integrated_conversation_system.history_manager.save_conversation(
                        user_id, text, ai_msg["answer"],
                        metadata={"source": "line_mention_fallback", "error_occurred": True}
                    )
                    print(f"[HISTORY] âœ… Saved fallback conversation to history")
                except Exception as save_error:
                    print(f"[WARNING] âŒ Failed to save fallback conversation: {save_error}")

            # ä¼šè©±å±¥æ­´ã«è¿½åŠ 
            CHAT_HISTORY.extend(
                [HumanMessage(content=text), HumanMessage(content=ai_msg["answer"])]
            )

            # LINEã«å¿œç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ï¼ˆã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å¯¾å¿œï¼‰
            answer_text = ai_msg["answer"]

            # ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç”¨ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ•´å½¢
            formatted_text = format_message_for_mobile(answer_text)

            # é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã¯åˆ†å‰²
            message_parts = split_long_message(formatted_text, max_length=1000)

            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
            if len(message_parts) == 1:
                # å˜ä¸€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆ
                reply_message = TextMessage(text=message_parts[0])
                line_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=event.reply_token, messages=[reply_message]
                    )
                )
                print(f"[REPLY] Sent single message: {message_parts[0][:100]}...")
            else:
                # è¤‡æ•°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«åˆ†å‰²ã•ã‚ŒãŸå ´åˆ
                reply_messages = [
                    TextMessage(text=part) for part in message_parts[:5]
                ]  # æœ€å¤§5ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ã§
                line_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=event.reply_token, messages=reply_messages
                    )
                )
                print(f"[REPLY] Sent {len(reply_messages)} split messages")

        # é€šå¸¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ï¼‰
        else:
            message_info = f"Received message from {user_id} in {group_id}"
            print(f"[USER] {message_info}: {text}")

            # ã‚ˆã‚Šè©³ç´°ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã§ä¿å­˜
            import time

            current_time = time.strftime("%Y-%m-%d %H:%M:%S")
            metadata = {
                "user": user_id,
                "timestamp": group_id,
                "saved_at": current_time,
                "message_type": "user_message",
            }

            vector_db.add_texts([text], metadatas=[metadata])
            print(
                f"[SAVE] Saved to ChromaDB: {text[:50]}..."
                if len(text) > 50
                else f"[SAVE] Saved to ChromaDB: {text}"
            )

            # ä¼šè©±å±¥æ­´ã‚·ã‚¹ãƒ†ãƒ ã«ã‚‚ä¿å­˜ï¼ˆå¿œç­”ãªã—ã®å ´åˆï¼‰
            try:
                integrated_conversation_system.history_manager.save_conversation(
                    user_id, text, "",  # å¿œç­”ãªã—ãªã®ã§ç©ºæ–‡å­—
                    metadata={"source": "line_message_only", "no_response": True}
                )
                print(f"[HISTORY] Saved user message to conversation history")
            except Exception as e:
                print(f"[WARNING] Failed to save to conversation history: {e}")

            # å®šæœŸçš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’è¡¨ç¤º
            if hasattr(chroma_improver, "_message_count"):
                chroma_improver._message_count += 1
            else:
                chroma_improver._message_count = 1

            if chroma_improver._message_count % 10 == 0:
                print(
                    f"[STATS] Processed {chroma_improver._message_count} messages. DB size check recommended."
                )

    except ValueError as e:
        print(f"[ERROR] ValueError in handle_message: {e}")
        traceback.print_exc()
    except KeyError as e:
        print(f"[ERROR] KeyError in handle_message: {e}")
        traceback.print_exc()
    except OSError as e:
        print(f"[ERROR] OSError in handle_message: {e}")
        traceback.print_exc()


def get_next_note_for_reminder():
    tomorrow = datetime.now() + timedelta(days=1)
    tomorrow_date = tomorrow.date()
    notes = chroma_improver.smart_similarity_search("[ãƒãƒ¼ãƒˆ]", k=20)
    for note in notes:
        import re

        date_patterns = re.findall(
            r"(\d{4}/\d{2}/\d{2}|(\d{1,2})æœˆ(\d{1,2})æ—¥)", note.page_content
        )
        for dp in date_patterns:
            # è¥¿æš¦å½¢å¼
            if isinstance(dp, str) and "/" in dp:
                try:
                    nd = datetime.strptime(dp, "%Y/%m/%d").date()
                    if nd >= tomorrow_date:
                        return note.page_content
                except Exception:
                    continue
            # æœˆæ—¥å½¢å¼
            elif isinstance(dp, tuple) and dp[1] and dp[2]:
                try:
                    year = tomorrow.year
                    nd = datetime(year, int(dp[1]), int(dp[2])).date()
                    if nd >= tomorrow_date:
                        return note.page_content
                except Exception:
                    continue
    if notes:
        return notes[0].page_content
    return "ç›´è¿‘ã®[ãƒãƒ¼ãƒˆ]ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"


if __name__ == "__main__":
    print("Starting Flask application...")
    print(f"Access token: {ACCESS_TOKEN[:20]}...")
    print(f"Channel secret: {CHANNEL_SECRET[:10]}...")
    print("Webhook endpoint: http://localhost:5000/callback")
    print("Health check endpoint: http://localhost:5000/")
    print("Flask app is now ready to receive requests!")

    # é–‹ç™ºç’°å¢ƒã§ã®å®‰å®šæ€§å‘ä¸Šã®ãŸã‚ãƒªãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’ç„¡åŠ¹åŒ–
    debug_mode = os.getenv("FLASK_DEBUG", "True").lower() == "true"
    use_reloader = os.getenv("FLASK_USE_RELOADER", "False").lower() == "true"

    # ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’ChromaDBã«ãƒ­ãƒ¼ãƒ‰
    debug_info = f"""
    [UMA3 DEBUG] Before load_chathistory_to_chromadb:
    CWD: {os.getcwd()}
    __file__: {__file__}
    sys.path[0]: {sys.path[0] if sys.path else 'None'}
    """
    print(debug_info)

    # ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚ä¿å­˜
    with open("debug_uma3_f5.log", "w", encoding="utf-8") as f:
        f.write(debug_info + "\n")

    load_chathistory_to_chromadb()

    after_debug = f"[UMA3 DEBUG] After load_chathistory_to_chromadb: CWD={os.getcwd()}"
    print(after_debug)

    # å®Œäº†ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
    with open("debug_uma3_f5.log", "a", encoding="utf-8") as f:
        f.write(after_debug + "\n")
        f.write("load_chathistory_to_chromadb() completed successfully\n")

    # monitoring_historyfile.py ã‚’ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰èµ·å‹•
    import subprocess

    monitoring_script = os.path.join("Lesson25", "uma3soft-app", "src", "monitoring_historyfile.py")
    if os.path.exists(monitoring_script):
        subprocess.Popen([sys.executable, monitoring_script])
        print(f"[INFO] Started monitoring script: {monitoring_script}")
    else:
        print(f"[WARNING] Monitoring script not found: {monitoring_script}")

    # Flaskã‚¢ãƒ—ãƒªèµ·å‹•
    app.run(host="0.0.0.0", port=5000, debug=debug_mode, use_reloader=use_reloader)
